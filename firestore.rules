/**
 * @fileoverview Firestore Security Rules for WhaleWatch100x.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data,
 * combined with public read access for curated content and service-restricted
 * writes for global data.
 *
 * Data Structure:
 * - User data is nested under /users/{userId}, ensuring data isolation.
 * - Wallets, Transactions, and Alerts are nested under the user's data tree,
 *   inheriting the same ownership.
 * - News feed items are stored in a top-level collection with denormalized
 *   `userId` field for efficient filtering.
 * - Article recommendations are stored in a top-level collection restricted to
 *   service accounts for modification.
 *
 * Key Security Decisions:
 * - User data is strictly isolated; users can only access their own information.
 * - List operations on user-owned subcollections are allowed to the owner.
 * - Article recommendations are publicly readable but only modifiable by backend
 *   services (simulated with `false` in this prototype).
 * - News feed items are associated with users through the `userId` field,
 *   allowing for personalized feeds.
 *
 * Denormalization for Authorization:
 * - NewsFeedItem: Includes the `userId` field directly in the document. This allows
 *   listing of news items specific to a user without complex queries or `get()` calls.
 */

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure access to user profile information. Only the user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create) - User with ID 'user123' can create their own profile.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "user123", "email": "test@example.com", "username": "testuser" } } }
     * @allow (get, update, delete) - User with ID 'user123' can read/write their own profile.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "user123", "email": "test@example.com", "username": "testuser" } } }
     * @deny (create) - User with ID 'user456' cannot create a profile for user 'user123'.
     *     Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "user123", "email": "test@example.com", "username": "testuser" } } }
     * @deny (get, update, delete) - User with ID 'user456' cannot access user 'user123's profile.
     *     Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "user123", "email": "test@example.com", "username": "testuser" } } }
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is not allowed for privacy reasons.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id; // Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure access to wallets owned by a specific user. Only the owning user can read/write wallets under their profile.
     * @path /users/{userId}/wallets/{walletId}
     * @allow (create) - User 'user123' can create a wallet under their profile.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "walletabc", "userId": "user123", "address": "0x...", "blockchain": "Ethereum" } } }
     * @allow (get, update, delete) - User 'user123' can read/write their own wallet.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "walletabc", "userId": "user123", "address": "0x...", "blockchain": "Ethereum" } } }
     * @deny (create) - User 'user456' cannot create a wallet for user 'user123'.
     *     Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "walletabc", "userId": "user123", "address": "0x...", "blockchain": "Ethereum" } } }
     * @deny (get, update, delete) - User 'user456' cannot access user 'user123's wallet.
     *     Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "walletabc", "userId": "user123", "address": "0x...", "blockchain": "Ethereum" } } }
     * @principle Enforces document ownership and hierarchical data access.
     */
    match /users/{userId}/wallets/{walletId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId; //Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure access to transactions for a specific wallet owned by a user. Only the owning user can access their transactions.
     * @path /users/{userId}/wallets/{walletId}/transactions/{transactionId}
     * @allow (create) - User 'user123' can create a transaction for their wallet 'walletabc'.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "tx123", "walletId": "walletabc", "token": "ETH", "amount": 1.0, "transactionType": "deposit", "timestamp": "2024-01-01T00:00:00Z" } } }
     * @allow (get, update, delete) - User 'user123' can read/write their own transaction.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "tx123", "walletId": "walletabc", "token": "ETH", "amount": 1.0, "transactionType": "deposit", "timestamp": "2024-01-01T00:00:00Z" } } }
     * @deny (create) - User 'user456' cannot create a transaction for user 'user123's wallet.
     *     Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "tx123", "walletId": "walletabc", "token": "ETH", "amount": 1.0, "transactionType": "deposit", "timestamp": "2024-01-01T00:00:00Z" } } }
     * @deny (get, update, delete) - User 'user456' cannot access user 'user123's transaction.
     *     Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "tx123", "walletId": "walletabc", "token": "ETH", "amount": 1.0, "transactionType": "deposit", "timestamp": "2024-01-01T00:00:00Z" } } }
     * @principle Enforces document ownership and hierarchical data access.
     */
    match /users/{userId}/wallets/{walletId}/transactions/{transactionId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure access to alerts created by a specific user. Only the owning user can manage their alerts.
     * @path /users/{userId}/alerts/{alertId}
     * @allow (create) - User 'user123' can create an alert.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "alertabc", "userId": "user123", "walletId": "walletabc", "alertType": "large_transaction", "threshold": 1000, "enabled": true } } }
     * @allow (get, update, delete) - User 'user123' can read/write their own alert.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "id": "alertabc", "userId": "user123", "walletId": "walletabc", "alertType": "large_transaction", "threshold": 1000, "enabled": true } } }
     * @deny (create) - User 'user456' cannot create an alert for user 'user123'.
     *     Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "alertabc", "userId": "user123", "walletId": "walletabc", "alertType": "large_transaction", "threshold": 1000, "enabled": true } } }
     * @deny (get, update, delete) - User 'user456' cannot access user 'user123's alert.
     *     Request: { "auth": { "uid": "user456" }, "resource": { "data": { "id": "alertabc", "userId": "user123", "walletId": "walletabc", "alertType": "large_transaction", "threshold": 1000, "enabled": true } } }
     * @principle Enforces document ownership and hierarchical data access.
     */
    match /users/{userId}/alerts/{alertId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId; // Enforce immutability of userId.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to article recommendations, but restricts write access.
     * @path /article_recommendations/{articleRecommendationId}
     * @allow (get, list) - Any user can read article recommendations.
     *     Request: { "auth": { "uid": null } }
     * @deny (create, update, delete) - No user can create/modify article recommendations through client-side code.
     *     Request: { "auth": { "uid": "user123" } }
     * @principle Public read access with service-restricted writes.
     */
    match /article_recommendations/{articleRecommendationId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Restrict to backend services with proper authentication.
    }

    /**
     * @description Allows read access to news feed items.  Write access is restricted, with userId validation.
     * @path /news_feed_items/{newsFeedItemId}
     * @allow (get, list) - Any user can read news feed items.
     *     Request: { "auth": { "uid": null } }
     * @allow (create) - Allows creating a news feed item with a matching userId.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "userId": "user123", "title": "Breaking News", "content": "...", "source": "Example News", "timestamp": "2024-01-01T00:00:00Z" } } }
     * @allow (update, delete) - User 'user123' can update/delete news feed item.
     *     Request: { "auth": { "uid": "user123" }, "resource": { "data": { "userId": "user123", "title": "Breaking News", "content": "...", "source": "Example News", "timestamp": "2024-01-01T00:00:00Z" } } }
     * @deny (create) - Does not allow creating a news feed item without a matching userId.
     *     Request: { "auth": { "uid": "user456" }, "resource": { "data": { "userId": "user123", "title": "Breaking News", "content": "...", "source": "Example News", "timestamp": "2024-01-01T00:00:00Z" } } }
     * @principle Public read access with owner-only writes, validated by userId.
     */
    match /news_feed_items/{newsFeedItemId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if true; // Public read access.
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid; // Requires sign-in and userId match.
      allow update: if isExistingOwner(resource.data.userId); // Only the owner can update.
      allow delete: if isExistingOwner(resource.data.userId); // Only the owner can delete.
    }
  }
}